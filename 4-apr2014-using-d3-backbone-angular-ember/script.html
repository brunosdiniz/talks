<!DOCTYPE html><html><head><meta charset="utf-8"><style>html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman',
              "Hiragino Sans GB", "STXihei", "微软雅黑", serif;
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

a{ color: #0645ad; text-decoration:none;}
a:visited{ color: #0b0080; }
a:hover{ color: #06e; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0 3px 0 3px;
}

::-moz-selection{background:rgba(255,255,0,0.3);color:#000}
::selection{background:rgba(255,255,0,0.3);color:#000}

a::-moz-selection{background:rgba(255,255,0,0.3);color:#0645ad}
a::selection{background:rgba(255,255,0,0.3);color:#0645ad}

p{
margin:1em 0;
}

img{
max-width:100%;
}

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}
h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; border-bottom:1px solid silver; padding-bottom: 5px; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
color:#666666;
margin:0;
padding-left: 3em;
border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }


pre , code, kbd, samp { 
  color: #000; 
  font-family: monospace; 
  font-size: 0.88em; 
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC; 
}
pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 5px 12px;}
pre code { border: 0px !important; padding: 0;}
code { padding: 0 3px 0 3px; }

b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%; outline:none;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style><title>script</title></head><body><h1 id="using-d3-with-backbone-angular-and-ember">Using D3 with Backbone, Angular and Ember</h1>
<h2 id="intro">Intro</h2>
<p>JavaScript applications are becoming more and more complex. This complexity has spawned numerous application frameworks, like Backbone, Angular and Ember. Fundamentally, these frameworks attempt to address a similar problem: in nontrivial applications, architectural mistakes are costly.</p>
<p>Every application has an architecture, even if it's not explicit. The goal of a framework is to enforce good architectural decisions within your application. For example, within the context of a complex application, most would agree that the following code</p>
<p>[jquery api call]</p>
<p>is an architectural mess, as it has a mixture of concerns:</p>
<ul>
<li>Network I/O</li>
<li>Handing user events</li>
<li>Manipulating application state data</li>
<li>Templating</li>
</ul>
<p>Of course, your code may not look like this, even if you're not using a framework; but the point is, frameworks try to make it hard to write code this poorly structured.</p>
<p>For example, in the above code we query the DOM to get some data about our user. Backbone makes it easy to keep this sort of model data in a separate layer, which is more scalable: you have a single source of truth for your model data, and you can ask that source whenever you need that data, instead of querying the DOM, which is fragile, could be in multiple places, depends on HTML/CSS implementation, etc.</p>
<p>And in Angular, we can use a directive to provide the template for our success handler, instead of writing it directly in our Javascript. It keeps the template's concerns apart from the data, and forces us to come up with an API for exactly what data our template needs to display.</p>
<p>If variations of the above code were replacated throughout our program, we may run into race conditions, where certain dependencies complete in unpredictable ways. The Ember run loop provides a mechanism for taking control of these situations.</p>
<p>In short, all three frameworks provide solutions to common problems that arise in building complex Javascript applications.</p>
<h3 id="the-costs-and-benefits-of-frameworks">The costs and benefits of frameworks</h3>
<p>In web development, as in most areas in life, there ain't no such thing as a free lunch. Using a framework comes with a cost: primarily, learning the specific abstractions of the framework.</p>
<p>These abstractions take time, both because you have to learn to 'think' in terms of them, and because you need to learn a new syntax for them. And this investment is nontrivial: it can take a long time to learn how to use a framework effectively.</p>
<p>Still, a growing number of people seem to be convinced that frameworks are proving their worth. The benefits that frameworks provide - when used appropriately, and for the correct problems - seem to be worth it. These benefits include consistency, organization, collaborative solutions to problems, code reuse, less time spent on trivial decision-making, and others.</p>
<p>Once we get "on board" with a framework, we start to think of certain pieces of our app in terms of the framework. Depending on the surface area of the framework, the amount of pieces in your app like this varies. But, for example, if we use a framework that provides a "router", we think of how our application moves through routes in terms of this particular object. It's not like we're ignoring everything we know about software, or putting aside our specific domain; but we definitely adopt architectural suggestions and learn to think "in terms of the framework."</p>
<h3 id="where-does-d3-come-in">Where does D3 come in?</h3>
<p>So how does D3 fit into all this? Well, visualizations have recently become more prominent in web applications. Companies like Square, Chart.io, Localytics, and Plotly feature visualizations as some of the main features of their web applications.</p>
<p>This means the code related to visualizations is also becoming larger, and more complex. But building interactive data visualizations in web applications is a relatively new phenomeon, and there's a lot we're still discovering. Because of this, it's easy for developers to think of the visualizations in their application as completely separate from all the other 'standard' pieces.</p>
<p>Also, examples from D3's community tend to be one-off, isolated. This is great for understanding and sharing code, but when it comes time to incorporate modularly into your bigger app, this isn't super helpful. Similarly, D3 code tends to be procedural, which also makes it difficult to incorporate into our applications, which tend to be object-oriented. The examples tend to be a set of instructions to produce a particular visualization, rather than an object with an interface, etc. There is <a href="/chart">some work</a> in this area, but again, the majority of examples don't implement this.</p>
<p>For all these reasons, it's easy for developers to write their data vis code separately, outside of the idioms of the framework - or more generally, your application's architecture. But this leads to the same problems that we saw at the beginning. It's just as easy to write highly coupled code that mixes concerns for data vis as it is for standard components.</p>
<h3 id="how-coupled-will-my-d3-code-be">How coupled will my D3 code be?</h3>
<p>Before I get too far, I don't want you to misunderstand me. I am not suggesting that you intersperse your D3 code among the various framework pieces. In fact, before starting a project with a framework you probably have already written a lot of d3 code; at the least, you have access to a lot of community code out there. There's no reason for you to rip it apart and meld it to your framework. That would make all your hard work on d3 not usable outside of that framework. This is probably a bad idea.</p>
<p>Instead, what I'm saying is this:</p>
<ul>
<li>When working on a large application using a modern framework, your'e building an object-oriented system. It's important to think of your D3 code in the same way, too.</li>
<li>Each framework has its own architecture. Think in terms of that architecture, and fit your D3 objects into that system</li>
<li>Embracing the framework's idioms will open up new possibilities for your d3 code</li>
</ul>
<h3 id="thesis">Thesis</h3>
<p>The thesis of this talk is essentially this: in applications where you're using a framework, and where d3 code is prominent, you should treat your D3 code as first-class, and embrace the framework's idioms. We want to do this for the same reasons we do it with the rest of our Javascript code:</p>
<ul>
<li>Improves organization, reuse and testability</li>
<li>Gives us unique and powerful ways to use our visualizations</li>
<li>Collaboration (share Ember components, Angular directives, etc.)</li>
<li>and more</li>
</ul>
<p>We want to take the lessons we're learnign from the frameworks, and not miss out on them in our D3 code.</p>
<p>Admittedly this is a young game. Patterns around both D3 and more generally large Javascript applications are still emerging. But we have learned some things about developing web applications in recent years, and it's important that we incorporate these lessons into our D3 code as well.</p>
<p>Now, there are a lot of frameworks out there, but we're going to focus on three: Backbone, Angular and Ember. We do this both because of their popularity, and because the goals of the three frameworks are different enough that we'll be able to illustrate how to use D3 in different contexts.</p>
<p>In all three frameworks, D3 code has most to do with the view layer of MVC.</p>
<p>For the rest of this talk, we're actually going to build up a chart that we can use with all three frameworks. We're going to see how each framework shapes our thinking about the chart as an object. It will influence the public api that we give the chart. Finally we'll see how to use the chart in each framework.</p>
<h2 id="object-orientizing-our-chart">Object-orientizing our chart</h2>
<p>Let's say that we work for some company, and we want to help our CEO understand how his revenues are distrubted across his clients. We check out the D3 examples page, and the bubble chart catches our eye. We decide to make a bubble chart that encodes client revenues in terms of area. That should give the business team an easy way to understand the revenue distribution.</p>
<p>So we come across <a href="http://bl.ocks.org/mbostock/4063269">this bubble chart example</a>, and pull down the source:</p>
<p>[something]</p>
<p>50 lines of code, not bad at all. Let's also pull down the data, and make sure we can get it running locally. It works! Let's change the data with some data that will be more like what we give it.</p>
<p>Looking at the original, we have something like</p>
<pre><code class="js">{
 &quot;name&quot;: &quot;flare&quot;,
 &quot;children&quot;: [
  {
   &quot;name&quot;: &quot;analytics&quot;,
   &quot;children&quot;: [
    {
     &quot;name&quot;: &quot;cluster&quot;,
     &quot;children&quot;: [
      {&quot;name&quot;: &quot;AgglomerativeCluster&quot;, &quot;size&quot;: 3938},
      {&quot;name&quot;: &quot;CommunityStructure&quot;, &quot;size&quot;: 3812},
      {&quot;name&quot;: &quot;HierarchicalCluster&quot;, &quot;size&quot;: 6714},
      {&quot;name&quot;: &quot;MergeEdge&quot;, &quot;size&quot;: 743}
     ]
    },
    ...
</code></pre>

<p>It's a big nested tree. For our purposes, we aren't worried about the hierarchy. Here's what our data looks like:</p>
<pre><code>{
 &quot;name&quot;: &quot;companies&quot;,
 &quot;children&quot;: [
  {&quot;name&quot;: &quot;Wayne Enterprises&quot;, &quot;size&quot;: 3938},
  {&quot;name&quot;: &quot;Stark Enterprises&quot;, &quot;size&quot;: 3812},
  {&quot;name&quot;: &quot;Acme Corp&quot;, &quot;size&quot;: 6714},
  {&quot;name&quot;: &quot;Dunder Mifflin&quot;, &quot;size&quot;: 743}
 ]
}
</code></pre>

<p>So, we've got a working chart. But like we said earlier, we don't want to just copy and paste this code wherever we need it. That's not how we'll be writing the rest of our Javascript code, so that's not how we'll write our D3 code. Instead, we'll make an object.</p>
<p>There are a few ways we can do this. Two common patterns in Javascript are prototypes and closures. Prototypes give us shared static methods, an easy way to add methods to our main object. Closures require more memory but give us private variables, and also prevent us from having to manage the context of <code>this</code>. We'll go with the latter, as it happens to be the pattern that D3 itself uses. You can read more about it here: [www.bost.ocks.org/mike/chart].</p>
<aside>
There is a library called [d3.chart] that was created to make building reusable, object-oriented charts easier. Be sure to check it out as an alternative to hand-rolling your own. Everything we talk about here also applies to charts made with `d3.chart`.
</aside>

<p>After some wrangling, we end up with a chart class:</p>
<p>[code wrangling]</p>
<p>In this case, the inner <code>chart</code> function is our closure; it takes care of creating the chart, using the configuration variables at the top of the bubbleChart function. We've also created getter/setters for the configuration variables, which act similar to jQUery methods: invoke with no argument, and you'll get the current property. Pass in a value, and you'll set the property. Subsequent calls to <code>chart()</code> will rerender the chart using the new config values.</p>
<p>Now we have a chart class! Use it like this:</p>
<pre><code class="js">var data = [get_some_data]

var chart = bubbleChart()
  .margin({top: 0, right: 20, bottom: 0, left: 20});
d3.select('body')
  .datum(root)
  .call(chart);
</code></pre>

<p>The getter/setters are our chart's interface; its public API. It's how we'll hook up with the primitives in our frameworks.</p>
<h2 id="backbone">Backbone</h2>
<p>Of these three frameworks, Backbone is the most lightweight. While not offering as many opinions as some of the other frameworks in the Javascript landscape, Backbone certainly has its idioms. At its heart, it provides you with a model layer to store your data, and an event system to tie your data to the DOM. To see how it works, let's look at a simple example.</p>
<h3 id="simple-view">Simple view</h3>
<p>Say we have a list of companies, similar to the data we used for the bubble chart:</p>
<pre><code class="js">[
  {name: &quot;Wayne Enterprises&quot;, revenue: 3938, cost: 1423},
  {name: &quot;Stark Enterprises&quot;, revenue: 3812, cost: 823},
  {name: &quot;Acme Corp&quot;, revenue: 6714, 2990},
  {name: &quot;Dunder Mifflin&quot;, revenue: 743, 1304}
]
</code></pre>

<p>In Backbone, we store arrays of objects in <code>collections</code>. It's as simple as:</p>
<pre><code class="js">var companies = new Backbone.Collection([
  {name: &quot;Wayne Enterprises&quot;, revenue: 3938, cost: 1423},
  {name: &quot;Stark Enterprises&quot;, revenue: 3812, cost: 823},
  {name: &quot;Acme Corp&quot;, revenue: 6714, cost: 2990},
  {name: &quot;Dunder Mifflin&quot;, revenue: 743, cost: 1304}
]);
</code></pre>

<p>This returns a new collection, which contains an array of <code>Backbone.Model</code> objects. The model objects themselves implement the default behavior. We can redefine them ourselves as we need custom behavior; for instance, to add a <code>.profit()</code> method that calculates the profit (revenue minus cost). For now, the default will do.</p>
<p>Now, we want to display these companies on the screen. In Backbone, as in the other two libraries, you typically want to break down your GUI into isolated chunks, and use a single View object to represent each chunk. In this case, we're going to render a list of companies somewhere (say, in a <code>&lt;ul&gt;</code> element). So that corresponds to a chunk of UI, and we'll make a <code>CompaniesView</code> for it.</p>
<p>The view will render our <code>companies</code> collection, and update itself if the collection changes:</p>
<pre><code class="js">var CompaniesView = Backbone.View.extend({

  initialize: function() {
    this.listenTo(this.collection, &quot;change add remove&quot;, this.render);
    this.render();
  },

  template: _.template(
    '&lt;ul&gt;&lt;% _.each(companies, function(company) { %&gt; &lt;li&gt;&lt;strong&gt;&lt;%= company.name %&gt;&lt;/strong&gt;: revenue: &lt;%= company.revenue %&gt;, cost: &lt;%= company.cost %&gt;&lt;/li&gt; &lt;% }); %&gt;&lt;/ul&gt;'
  ),

  render: function() {
    // this.$el.html(this.template(this.model.attributes));
    this.$el.html(this.template({
      companies: this.collection.toJSON()
    }));

    return this;
  }

});
</code></pre>

<p>On init, we set up a listener to rerender when the view's collection's changes, and kick off an initial render. Next, look at the render function. This sets the <code>html</code> of the view's DOM element. The way it does this is by rendering an underscore template, and passing in the companies data. So this is the core idea: the template is being rendered with the collection as its context.</p>
<p>The template itself is simple:</p>
<pre><code class="html">&lt;ul&gt;
  &lt;% _.each(companies, function(company) { %&gt;
    &lt;li&gt;&lt;strong&gt;&lt;%= company.name %&gt;&lt;/strong&gt;: revenue: &lt;%= company.revenue %&gt;, cost: &lt;%= company.cost %&gt;&lt;/li&gt;
  &lt;% }); %&gt;
&lt;/ul&gt;
</code></pre>

<p>This is in a string right now, but as they get more complex, you typically save them in a separate file.</p>
<p>Now, this is just a class definition. We just need to actually instantiate the view, pass in its collection, and give it a DOM element to render in:</p>
<pre><code class="js">var list = new CompaniesView({
  el: '.company-list',
  collection: companies
});
</code></pre>

<p>There, we can see the list has been rendered. Now, let's see it update in response to changing data.</p>
<p>The <code>companies</code> collection is a global object, so just change one of the properties in the console:</p>
<pre><code class="js">companies.at(3).set('name', &quot;Dwight's Beet Farms&quot;);
companies.at(3).destroy()
</code></pre>

<p>and you'll see the DOM updates automatically.</p>
<p>So, this is the idea, how you tie Backbone views to the data. Now, let's see how to do it with D3.</p>
<h3 id="d3-view">D3 view</h3>
<p>In our OOP chart from above, we feed our chart some data then call <code>chart()</code> to render our chart. So, when thinking about incorporating our chart into our Backbone application, we need to think of these pieces: </p>
<ul>
<li>Where should the data come from?</li>
<li>When should we call render?</li>
</ul>
<p>For the first question, the natural place is our Backbone collections. Typically we'll have something already - like our <code>companies</code> collection from above. Our collections will usually have more data than what our chart needs. In this case, each company has both revenue and cost, but we just show one dimension in our bubble chart. So we can add a <code>chartData</code> method to our backbone collection, where we do the data manipulation, to return what our chart needs:</p>
<pre><code class="diff">- var companies = new Backbone.Collection([
-   {name: &quot;Wayne Enterprises&quot;, revenue: 3938, cost: 1423},
-   {name: &quot;Stark Enterprises&quot;, revenue: 3812, cost: 823},
-   {name: &quot;Acme Corp&quot;, revenue: 6714, cost: 2990},
-   {name: &quot;Dunder Mifflin&quot;, revenue: 743, cost: 1304}
- ]);

+ var CompanyCollection = Backbone.Collection.extend({
+   chartData: function() {
+     return {
+       name: 'compaines',
+       children: this.map(function(c) { 
+         return {name: c.get('name'), size: c.get('revenue')};
+       })
+     }
+   }
+ });
+ 
+ var companies = new CompanyCollection([
+   {name: &quot;Wayne Enterprises&quot;, revenue: 3938, cost: 1423},
+   {name: &quot;Stark Enterprises&quot;, revenue: 3812, cost: 823},
+   {name: &quot;Acme Corp&quot;, revenue: 6714, cost: 2990},
+   {name: &quot;Dunder Mifflin&quot;, revenue: 743, cost: 1304}
+ ]);
</code></pre>

<p>So, one thing to point out here. Note that we're using this method to massage the data into the correct format. We could have also extended our chart to accept different formats of data, or made data accessors available on our chart which the user could customize; so in this case, we'd pass in our normal data, but then when instantiating the chart we'd specify the accessors (for example, use 'revenue' instead of 'size'). These issues turn out to be pretty nontrivial and it takes some work to get them right. Typically in smaller cases it's fine to do them anywhere blah blah blah.</p>
<p>Now we have the data, we need the chart view object itself.</p>
<pre><code class="js">var BubbleChartView = Backbone.View.extend({

  chart: d3.charts.bubble(),

  initialize: function() {
    this.listenTo(this.collection, &quot;change add remove&quot;, this.render);

    this.render();
  },

  render: function() {
    d3.select(this.el)
      .datum(this.collection.chartData())
      .call(this.chart);

    return this;
  }

});
</code></pre>

<p>We create an instance of our OOP reusable chart object, and store it on the chart property of our Backbone view. Our init function is the same as the last view: listen to changes in the collection, and kick off an initial render. The render function itself selects the view's base element with d3, binds the collections data (that we get from chartData function), and calls the chart.</p>
<p>It worked! Now, change the collection again, and watch the chart respond:</p>
<pre><code class="js">companies.at(2).set('revenue', 1000);
companies.at(0).destroy()
</code></pre>

<p>Looking good.</p>
<h3 id="some-things-to-consider">Some things to consider</h3>
<p>Note that there are many unanswered questions:</p>
<ul>
<li><strong>View cleanup.</strong> Who's responsible for instantiating/destroying the View instances? This is more complicated than it seems, since there could be [dangling event listeners].</li>
<li><strong>View hierarchy.</strong></li>
<li><strong>Lazy rendering.</strong></li>
</ul>
<p>View managements can get hairy with d3 views, as some approaches you would take with more standard views won't work with d3. For example, in our examples we added a call to render on init, so the view rendered itself as soon as it was instantiated. In our example, we also passed it an existing dom element, so it rendered directly to the DOM. But another approach is to manually append the view to the DOM. One way to do this is for some other object ot instnatiate the view, call render, populating the views .el property with the rendered template, adn then appending that <code>el</code> to the document. For this to work, the html is created in memory. In d3, we can't do this. D3 needs a dom element that exists in the live DOM in order to render. So, if your application is doing something like this, you'll have to rethink it a bit. You could have <code>render</code> simplay append a blank div with a class, and then have another method <code>renderChart</code> that actually renders the chart - though now your managing object would have to know this, too.</p>
<h2 id="angular">Angular</h2>
<aside>Don't need jQuery, but we're using it for better selections</aside>

<p>Angular sits at the intersection of the three frameworks. Whereas Backbone provides more of a skeleton to help you store your data outside of the DOM, Angular comes with additional powerful abstractions, and a data binding layer. Most relevant for our purposes are directives.</p>
<p>Directives are similar in purpose to Backbone views: they are designed to encapsulate a chunk of your GUI. The main difference is that instead of manually being responsible for instantiating a view and rendering it to a particular element in the DOM, you use the template layer itself to insert directives. Let's look at a simple example.</p>
<h3 id="simple-view_1">Simple view</h3>
<p>To render data to our DOM, we first need somewhere to store the data. In Backbone, we created a collection to store our data. In Angular, there aren't any special objects that represent models or arrays of models; we just use plain on Javascript arrays and objects. However, to make the data available to our template, we use controllers.</p>
<p>We can make a controller for our companies like this:</p>
<pre><code class="js">angular.module('d3-demo', [])

  .controller('CompaniesCtrl', ['$scope', function($scope) {

    $scope.companies = [
      {name: &quot;Wayne Enterprises&quot;, revenue: 3938, cost: 1423},
      {name: &quot;Stark Enterprises&quot;, revenue: 3812, cost: 823},
      {name: &quot;Acme Corp&quot;, revenue: 6714, cost: 2990},
      {name: &quot;Dunder Mifflin&quot;, revenue: 743, cost: 1304}
    ];

  }]);
</code></pre>

<p>Here we're specifying <code>$scope</code> as a dependency. Scope in Angular is like a ViewModel or Presenter, if you're familiar with those patterns. We simply attach our array of companies to the scope, and that data becomes available to the template.</p>
<p>Now, in our template we can initiate an Angular app, and designate which portion of DOM our <code>CompaniesCtrl</code> will manage:</p>
<pre><code class="html">&lt;body ng-app=&quot;d3-demo&quot;&gt;
  &lt;div ng-controller=&quot;CompaniesCtrl&quot;&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p>Template syntax in Angular uses {{. Let's create a list of our companies:</p>
<pre><code class="html">&lt;body ng-app=&quot;d3-demo&quot;&gt;
  &lt;div ng-controller=&quot;CompaniesCtrl&quot;&gt;
    &lt;div ng-repeat=&quot;c in companies&quot;&gt;
      &lt;h3&gt;{{company.name}}&lt;/h3&gt;&lt;p&gt;The revenue was {{company.revenue}}&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p>We use <code>ng-repeat</code> to iterate through our companies, similar to how we used <code>_.each</code> in Backbone.</p>
<!-- We have the `select` method, which we can use to make a company's isActive property true. We want this to occur whenever a user clicks on a company. To do that, it's simple:

wzxhzdk:15


We can see that `isActive` starts out undefined, and then toggles between true and false whenever the user clicks a company. Now, let's have the class on the company's `<li>` element correspond to whether it's active or not:


wzxhzdk:16


The `ng-class` expression tells Angular to add the "active" class if c.isActive evaluates to true. After adding some CSS, we can now see the effect being toggled. So this is how we can bind classes to our model properties, and add interaction to our templates. Notice that every time we use any of htese variables in our template, we're referencing the same underlying data on our scope. This way, we don't have to worry about keeping different portions of our UI in sync. The data binding takes care of making sure each chunk of UI is subscribed to the correct events on each model and collection, like we did in Backbone.
 -->

<p>Now, let's add a filter to our list. This turns out to be rather simple. The <code>ng-repeat</code> tag, which we used to iterate over our list, allows Unix-style piping. For example, if we add the following filter</p>
<pre><code class="html">...
  &lt;div ng-repeat=&quot;c in companies | filter:'Enterprise'&quot;&gt;
...
</code></pre>

<p>we'll only see companies who have "Enterprise somewhere in their properties.</p>
<p>Instead of hard-coding the filter in, let's add a search box. We'll bind the text of the search box to a new model on our scope, and use that as our filter:</p>
<pre><code class="diff">&lt;body ng-app=&quot;d3-demo&quot;&gt;
  &lt;div ng-controller=&quot;CompaniesCtrl&quot;&gt;
+   &lt;input type=&quot;text&quot; ng-model=&quot;query&quot;&gt;

+   &lt;div ng-repeat=&quot;c in companies | filter:query&quot;&gt;
      &lt;h3&gt;{{company.name}}&lt;/h3&gt;&lt;p&gt;The revenue was {{company.revenue}}&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p>If you try it, you'll see everything is working. <code>ng-model</code> let us bind the value of the text input to the <code>query</code> model, which we then use to filter our companies. Pretty handy stuff!</p>
<p>Finally, let's add a control to let the user toggle between revenue and cost. Just like with the filter, we'll add a new model to store the data (whether the revenue or cost is being shown):</p>
<pre><code class="diff">&lt;body ng-app=&quot;d3-demo&quot;&gt;
  &lt;div ng-controller=&quot;CompaniesCtrl&quot;&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;query&quot;&gt;
+   &lt;form&gt;
+     &lt;input type=&quot;radio&quot; ng-model=&quot;selectedItem&quot; value=&quot;revenue&quot;&gt;Revenue
+     &lt;input type=&quot;radio&quot; ng-model=&quot;selectedItem&quot; value=&quot;cost&quot;&gt;Cost
+   &lt;/form&gt; 

    &lt;div ng-repeat=&quot;c in companies | filter:query&quot;&gt;
      &lt;h3&gt;{{company.name}}&lt;/h3&gt;&lt;p&gt;The revenue was {{company.revenue}}&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p>Since we've bound both radio buttons to <code>selectedItem</code>, Angular will automatically set the value of <code>selectedItem</code> to whichever radio button is toggled.</p>
<p>We can now use this property in our template:</p>
<pre><code class="diff">&lt;body ng-app=&quot;d3-demo&quot;&gt;
  &lt;div ng-controller=&quot;CompaniesCtrl&quot;&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;query&quot;&gt;
    &lt;form&gt;
      &lt;input type=&quot;radio&quot; ng-model=&quot;selectedItem&quot; value=&quot;revenue&quot;&gt;Revenue
      &lt;input type=&quot;radio&quot; ng-model=&quot;selectedItem&quot; value=&quot;cost&quot;&gt;Cost
    &lt;/form&gt; 

    &lt;div ng-repeat=&quot;c in companies | filter:query&quot;&gt;
+     &lt;h3&gt;{{c.name}}&lt;/h3&gt;&lt;p&gt;The {{selectedItem}} was {{c[selectedItem]}}&lt;/p&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p>It turns out that <code>ng-controller</code>, <code>ng-repeat</code> and <code>ng-model</code> are all Angular directives. We'll now make our own custom directive that will let us separate out our display of company info.</p>
<h3 id="a-basic-directive">A basic directive</h3>
<p>Directives in Angular let you make custom elements. They encapsulate portions of your GUI, both look and behavior. In our example above, we repeated a chunk of HTML for each of our companies. This seems like a great candidate for a directive - let's call it the "CompanyInfo" directive.</p>
<p>To define our directive, use the <code>.directive</code> function. The entire directive is pretty small, so let's look at it first, then explain each piece:</p>
<pre><code class="javascript">angular.module('d3-demo', [])

  .controller('CompaniesCtrl', ['$scope', function($scope) {
    ...
  })

  .directive('companyInfo', function() {
    return {
      restrict: 'E',
      template: '&lt;h3&gt;{{company.name}}&lt;/h3&gt;&lt;p&gt;The {{selectedItem}} was {{company[selectedItem]}}&lt;/p&gt;',
      scope: {
        company: '=',
        selectedItem: '='
      }
    };
  })
</code></pre>

<p>Our directive function simply returns an object with some properties. Sometimes there's more work to do, but for this simple directive, this is all we need. Angular converts camelCased names to hyphenated names for rendering, so we'd use this directive like this:</p>
<pre><code class="html">&lt;company-info&gt;&lt;/company-info&gt;
</code></pre>

<p>When creating directives, we first decide if we want to use the directive as an element (like a <div> or <p>), or an attribute (such as the checked attribute in a checkbox input, <input checked />). We want to use this directive as an element, so we set the <code>restrict</code> property to E, for element.</p>
<aside>Directives can also be comments or classes, but you should generally stick to elements and attributes.</aside>

<p>The <code>template</code> property is just what it sounds like: it's the template for our directive, the DOM that will replace it when we use it in our HTML. Here, we simply have added what used to be in between the <code>ng-repeat</code> part of our HTML.</p>
<p>The final property in our return object is the <code>scope</code> property. If we hadn't defined this property, the variables in our <code>template</code> would have corresponded to whatever scope our template was rendered in. For example, in our main controller, say we had a <code>favoriteCompany</code> model defined. In our directive - just like in the rest of the HTML for that controller - we could display information from that model: {{ favoriteCompany.name }}.</p>
<p>However, when our directive has its own <code>scope</code> property, that creates an isolated scope for that directive. This means the directive's template no longer has access to the outer scope in which it is being rendered; {{ favoriteCompany.name }} would just render blank, in that case.</p>
<p>To remedy this, we can pass data in explicitly to our directive using attributes. In this way, if we rendered</p>
<pre><code class="html">&lt;company-info favorite-company=&quot;companies.1&quot;&gt;&lt;/company-info&gt;
</code></pre>

<p>then <code>favoriteCompany</code> would be defined in our directive's template. Now, this seems like a bit of a run-around, just to get the same data rendered to the screen. Why go through the ceremony of creating an isolated scope in the first place?</p>
<p>The main reason is that by forcing whoever's using the directive to pass in all the data explicitly, it makes the directive more reusable. Everywhere it's used, it won't function correctly unless the data has been passed in. It makes it easier to see what's going on, and prevents possible bugs arising from the directive reaching into the outer scope.</p>
<p>So, in our example, we created two variables for our directive's local scope:</p>
<pre><code class="js">scope: {
  company: '=',
  selectedItem: '='
}
</code></pre>

<p>Now, whatever data we pass in to the <code>company</code> and <code>selected-item</code> attributes of the directive will be available in the directive's isolated scope as the variables <code>company</code> and <code>selectedItem</code>.</p>
<aside>The `'='` tells our directive to assign whatever's passed into the `company` attribute to the `company` property of our directive's isolated scope. We could also use different names for the attribute name and the property name. See [here]() for more details.</aside>

<p>Our directive is ready to go! Let's update our main template:</p>
<pre><code class="diff">&lt;body ng-app=&quot;d3-demo&quot;&gt;
  &lt;div ng-controller=&quot;CompaniesCtrl&quot;&gt;
    &lt;input type=&quot;text&quot; ng-model=&quot;query&quot;&gt;
    &lt;form&gt;
      &lt;input type=&quot;radio&quot; ng-model=&quot;selectedItem&quot; value=&quot;revenue&quot;&gt;Revenue
      &lt;input type=&quot;radio&quot; ng-model=&quot;selectedItem&quot; value=&quot;cost&quot;&gt;Cost
    &lt;/form&gt; 

+   &lt;company-info ng-repeat=&quot;c in companies | filter:query&quot; company=&quot;c&quot; selectedItem=&quot;selectedItem&quot;&gt;
+   &lt;/company-info&gt;
-   &lt;div ng-repeat=&quot;c in companies | filter:query&quot;&gt;
-     &lt;h3&gt;{{c.name}}&lt;/h3&gt;&lt;p&gt;The {{selectedItem}} was {{c[selectedItem]}}&lt;/p&gt;
-   &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;
</code></pre>

<p>Now this part of our GUI is encapsulated and has its own scope. It will be easier to extend with additional behavior, and will be more maintainable as our app grows in complexity.</p>
<p>That's it for our basic directive! We'll now see how to encapsulate our D3 code within another custom directive.</p>
<h3 id="d3-directive">D3 directive</h3>
<p>Our D3 directive looks very similar to our <code>companyInfo</code> directive, with one main exception: we need a <code>link</code> function:</p>
<pre><code class="javascript">.directive('bubbleChart', function() {

  var chart = d3.charts.bubble();

  return {
    restrict: 'E',
    scope: {
      data: '='
    },

    link: function(scope, element, attrs) {

      scope.$watch('data', function(data) {

        d3.select(element[0])
          .datum(data)
          .call(chart);

      });
    }
  };
})
</code></pre>

<p>The <code>link</code> function gives our directive access to the DOM element it's being rendered to. Since we need to use Javascript to render our D3 chart (rather than using just HTML), we need to put all of our D3 code here.</p>
<p>Before we get to the <code>link</code> function, we instantiate our bubble chart. We also make our directive element-restricted. We actually don't need a template, since we'll just render our D3 chart directly to the directive's container element. Finally, we create a isolated scope for our directive with a single <code>data</code> property, which our chart will consume.</p>
<p>The link function itself is rather simple. Its parameters are the directive's scope, its DOM element, and any attributes set on the directive. We see the familiar call to our chart function:</p>
<pre><code class="js">scope.$watch('data', function(data) {

  d3.select(element[0])
    .datum(data)
    .call(chart);

});
</code></pre>

<p>We want to call this every time <code>data</code> changes, so we register a <code>$watch</code> listener on it. And that's it! We can now use our shiny new custom directive in our HTML:</p>
<pre><code class="html">&lt;bubble-chart data=&quot;?&quot;&gt;&lt;/bubble-chart&gt;
</code></pre>

<p>All we need to do is get the data.</p>
<h3 id="massaging-the-data">Massaging the data</h3>
<p>To actually render our chart, we need to pass in some data. We can't just pass in the raw <code>companies</code> model, because just like in our Backbone app, our chart expects its data in a certain format. </p>
<aside>We could of course alter our chart to make it accept data that looks like our plain `companeis` object, and in this situation that may make sense. But more generally, you will almost always need to manipulate your model data before passing it into your chart objects, so it's good to have an idea about where you can do that.</aside>

<p>Let's add a function in our main controller that formats the data for our chart:</p>
<pre><code class="diff">.controller('CompaniesCtrl', ['$scope', function($scope) {

  $scope.selectedItem = &quot;revenue&quot;;

  $scope.companies = [
    {name: &quot;Wayne Enterprises&quot;, revenue: 3938, cost: 1423},
    {name: &quot;Stark Enterprises&quot;, revenue: 3812, cost: 823},
    {name: &quot;Acme Corp&quot;, revenue: 6714, cost: 2990},
    {name: &quot;Dunder Mifflin&quot;, revenue: 743, cost: 1304}
  ];

+ $scope.chartData = {
+   name: 'companies',
+   children: $scope.companies.map(function(c) { 
+     return {name: c.name, size: c[$scope.selectedItem]};
+   })
+ };
}])
</code></pre>

<p>Now we can render our chart like this</p>
<pre><code class="html">&lt;bubble-chart data=&quot;chartData&quot;&gt;&lt;/bubble-chart&gt;
</code></pre>

<p>It works! But you'll notice something - the chart doesn't update when we filter the companies. That's because we're applying the filter to the list, but not our chart's data.</p>
<p>Instead of duplicating the filtering, we'll create a new model <code>filteredCompanies</code>, and share it across both of our directives. We'll register it as a listener to the <code>query</code> model, so that whenever the query changes, the <code>filteredCompanies</code> model is updated.</p>
<p>We can inject the same $filter service we used in our template so we can use it in our controller. Here's the JavaScript</p>
<pre><code class="javascript">.controller('CompaniesCtrl', ['$scope', '$filter', function($scope, $filter) {

  ... 

  $scope.$watch('query', function(q) {
    $scope.filteredCompanies = $filter('filter')($scope.companies, q);
  });
}])
</code></pre>

<p>and the HTML</p>
<pre><code class="diff">- &lt;company-info ng-repeat=&quot;c in companies | filter:query&quot; company=&quot;c&quot; selectedItem=&quot;selectedItem&quot;&gt;
- &lt;/company-info&gt;

+ &lt;company-info ng-repeat=&quot;c in filteredCompanies&quot; company=&quot;c&quot; selected-item=&quot;selectedItem&quot; &gt;
+ &lt;/company-info&gt;
</code></pre>

<p>We'll also move our <code>chartData</code> model into a $watch, so it gets updated whenever <code>filteredCompanies</code> is updated:</p>
<pre><code class="diff">$scope.$watch('filteredCompanies', function(filteredCompanies) {

  $scope.chartData = {
    name: 'companies',
    children: filteredCompanies.map(function(c) { 
      return {name: c.name, size: c[$scope.selectedItem]};
    })
  };

});
</code></pre>

<p>Finally, we also want to update this data when <code>selectedItem</code> changes. Since our <code>chartData</code> will now be watching both <code>filteredCompanies</code> and <code>selectedItem</code>, we use <code>watchCollection</code>:</p>
<pre><code class="diff">+ $scope.$watchCollection('[filteredCompanies, selectedItem]', function(arr) {
- $scope.$watch('filteredCompanies', function(filteredCompanies) {

  $scope.chartData = {
    name: 'companies',
+   children: arr[0].map(function(c) { 
+     return {name: c.name, size: c[arr[1]]};
+   })
-   children: filteredCompanies.map(function(c) { 
-    return {name: c.name, size: c[$scope.selectedItem]};
-   })
  };

});
</code></pre>

<p>That's it! Our chart now reacts to the query as the user searches through our companies. Cool!</p>
<h3 id="one-more-update">One more update</h3>
<p>You'll notice that if we type a query in our search box that doesn't return any companies, our bubble chart remains in whatever state it was in last. We'd like the chart to represent the filtered companies, even if that means there are none. So first, let's update our bubble chart to deal with the case of <code>null</code> data.</p>
<p>So, in our bubble chart code, before we start manipulating the nodes, we'll add a check for null data:</p>
<pre><code class="js">if (!data.children.length) {
  g.html('')
    .append('text')
    .attr('class', 'message')
    .text('No data');
  return false;
} else {
  g.select('.message').remove();
}
</code></pre>

<p>We first clear whatever existing SVG elements were in the main group, then append a text element. We give it a class, so we can remove it next time we render the chart with non-null data.</p>
<p>It works! But what we'd really like is for the message to say "No companies." Instead of hard-coding that into our chart, we'll create a new private property with an accessor:</p>
<pre><code class="diff">    bubble = d3.layout.pack()
      .sort(null)
      .size([diameter-margin.left, diameter-margin.top])
+      .padding(1.5),
+   emptyMessage = 'No data';

function chart(selection) {
  selection.each(function(data) {

...

if (!data.children.length) {
  g.html('')
    .append('text')
    .attr('class', 'message')
+   .text(emptyMessage);
-   .text('No data');
  return false;
} else {
  g.select('.message').remove();
}

...

+ chart.emptyMessage = function(_) {
+   if (!arguments.length) return emptyMessage;
+ 
+   emptyMessage = _;
+ 
+   return chart;
+ };

</code></pre>

<p>Now we can specify the option in our directive. We could set it directly on our chart instance, but let's add it as an attribute:</p>
<pre><code class="diff">.directive('bubbleChart', function() {

  var chart = d3.charts.bubble()

  return {
    restrict: 'E',
    scope: {
      data: '='
    },

    link: function(scope, element, attrs) {

      scope.$watch('data', function(data) {

        d3.select(element[0])
          .datum(data)
          .call(chart);

      });
    }
  };
})
</code></pre>

<p>Now we can use it in our HTML</p>
<pre><code class="html">&lt;bubble-chart data=&quot;chartData&quot; empty-message=&quot;No companies.&quot;&gt;&lt;/bubble-chart&gt;
</code></pre>

<p>and everything works as expected!</p>
<h3 id="some-things-to-consider_1">Some things to consider</h3>
<p>Notice how at the beginning, we didn't have to touch our bubble chart. Until we wanted ot add new functionality, our d3 object was completley reusable in this situation. Note that this is not just important across different frameworks, but even within the same application. Reuse - and the corollary of no duplication - is one of the most important tenants to follow in software development. We saw here that we get the exact same benefits when applying this discipline to our D3 code. This pattern makes it easy to reuse our custom visualizations in multiple places with subtle customized differences. Pretty cool!</p>
<p>Also, when we did come to a point in our app where we needed to extend our chart object, we did it in a way that was completely separate from our angular app. Our self-contained chart object gained functionality in a completely reusable way, and then we went back and augmented our directive to take advantage of the new functionality. The new chart object would still work with our Backbone code. So this is the advantage of this approach. Keeping our D3 code decoupled from our Angular code makes it more reusable, both for Angular and non-Angular devs.</p>
<p>But again, note that "decoupled" doesn't mean "second-class". Our D3 code is as prominant in this app as our other custom directive. We treat our bubble chart as a chunk of GUI with its own layout and functionality. And treating it just like we treat the rest of the pieces of our app influenced our design of the D3 object. We let how we were structuring our app and the individual pieces of the Angular framework provide feedback on how we could improve teh API of our chart ot make it more generic, reusable and valuable. This demo jsut touches the surface, but you can imagine what kind of D3 code you can build by letting all of Angular's cool tricks influence your charts.</p>
<ul>
<li>Another approach: http://alexandros.resin.io/angular-d3-svg/. More about this later.</li>
</ul>
<h2 id="ember">Ember</h2>
<p>Ember is certainly the most opinionated framework of the three. But all this really means is that there tends to be a well-defined way to do whatever it is you're trying to do. For example, if you want to get data into your application and you were writing your code by hand, you can imagine coming up with several reasonable places to put your AJAX requests. In Ember, the Route object is where data requests go, most of the time. Similarly, if you need to manipulate your raw data to provide different "sub-views" for your view, you do these in Ember controllers. So there tends to be a well-defined set of opinions around where you do things. And it's important to learn about these things, because certain objects in Ember have easy access to a restricted set of other objects. It's much more difficult to go outside of these conventions and try to do it your own way - and it's like that on purpose.</p>
<p>To incorporate our D3 into our Ember app, then, it's important (just as in the other frameworks) to learn where the reusable GUI chunk fits in. Ember gives us components - isolated objects that are responsible for portions of the GUI, styling, structure and functionality. They are comparable to directives in Angular.</p>
<p>First, we'll build a simple Ember component, and see how it interacts with the rest of our application.</p>
<h3 id="simple-view_2">Simple view</h3>
<p>Routes are central to Ember, because the Ember's router acts as a state machine that coordinates all the moving pieces of your app as your user navigates around. Therefore, when building an Ember app, we typically start out by defining the routes.</p>
<p>Let's have a route for all our companies, and then routes for individual companies, in a sort of master-detail fashion:</p>
<pre><code class="javascript">App = Ember.Application.create();

App.Router.map(function() {
  this.resource('companies', { path: '/' }, function() {
    this.resource('company', { path: '/:company_id' });
  });
});
</code></pre>

<p>This router lets us view the <code>companies</code> resource when we visit <code>/</code>, and view a specific <code>company</code> when we visit <code>/[id]</code>, <code>/2</code> for instance.</p>
<p>Now, where do we actually put our data? In Ember, routes (individual routes, not the router) are responsible for getting data based on the URL. For our <code>companies</code> resource, we want to return the same array of companies we've been using throughout this tutorial. We do that in the <code>model</code> hook of the <code>CompaniesRoute</code>:</p>
<pre><code class="javascript">App.CompaniesRoute = Em.Route.extend({
  model: function() {
    // Typically, make an AJAX request
    return [
      {id: 1, name: &quot;Wayne Enterprises&quot;, revenue: 3938, cost: 1423},
      {id: 2, name: &quot;Stark Enterprises&quot;, revenue: 3812, cost: 823},
      {id: 3, name: &quot;Acme Corp&quot;, revenue: 6714, cost: 2990},
      {id: 4, name: &quot;Dunder Mifflin&quot;, revenue: 743, cost: 1304}
    ];
  }
});
</code></pre>

<p>If we run the app, we don't see any errors, but we also don't see anything on the screen! Let's create a template to display the data.</p>
<p>When we're at <code>/</code>, the <code>CompaniesRoute</code>, Ember looks for a <code>companies</code> template to render out DOM. We can define a Handlebars templateone in our HTML, similar to how we defined underscore templates for Backbone:</p>
<pre><code class="html">&lt;script type=&quot;text/x-handlebars&quot; id=&quot;companies&quot;&gt;
  &lt;ul class=&quot;company-list&quot;&gt;
    {{#each}}
      &lt;li&gt;{{name}}&lt;/li&gt;
    {{/each}}
  &lt;/ul&gt;
&lt;/script&gt;
</code></pre>

<p><code>each</code> iterates over all the models for the current route, and in this case we just display the name of the company in a list. Alright, so everything's working so far!</p>
<p>Now, what about the detail view of our master-detail GUI? When we visit <code>/1</code>, we want to see the details of "Wayne Enterprises." We go thorugh the same process that we did for our <code>comapnies</code> route. First, we create the route, and return the data in the <code>model</code> hook:</p>
<pre><code class="js">App.CompanyRoute = Em.Route.extend({
  model: function(params) {
    return this.modelFor('companies').findBy('id', +params.company_id);
  }
})
</code></pre>

<p>In this case, since <code>company</code> is a child of <code>companies</code>, we can just look into the model for the <code>companies</code> parent route, and find the object that has the correct id. The <code>params</code> object is how we get the id from the URL.</p>
<p>We also need to create a template for our <code>company</code> route:</p>
<pre><code class="html">&lt;script type=&quot;text/x-handlebars&quot; id=&quot;company&quot;&gt;
  &lt;h2&gt;{{name}}&lt;/h2&gt;

  &lt;p&gt;Last year we made {{revenue}}. Costs were {{cost}}.&lt;p&gt;

&lt;/script&gt;
</code></pre>

<p>Now, if you visit <code>/1</code>, you'll notice...nothing! Where's our template?</p>
<p>We actually haven't told Ember where we want it to render. Because our <code>company</code> resource is a child of our <code>companies</code> resource, Ember is trying to render both templates. We need to specify where in our <code>companies</code> template we want Ember to render our <code>company</code> template - and we do this using the <code>{{outlet}}</code> tag.</p>
<p>So, if we add an outlet to our <code>companies</code> template, Ember will be able to also render the <code>company</code> template when we visit <code>/1</code>:</p>
<pre><code class="diff">&lt;script type=&quot;text/x-handlebars&quot; id=&quot;companies&quot;&gt;
  {{#each}}
    &lt;p&gt;{{name}}&lt;/p&gt;
  {{/each}}

+ &lt;div class=&quot;detail&quot;&gt;
+   {{outlet}}
+ &lt;/div&gt; 
&lt;/script&gt;
</code></pre>

<p>Now we visit <code>/1</code>, and it works! We can see our company details now. </p>
<p>Instead of forcing our users to type in <code>/1</code> and <code>/2</code> into the URL, we want to give them some links. Let's change the static text in our <code>companies</code> template to links, using Ember's link helper:</p>
<pre><code class="diff">&lt;script type=&quot;text/x-handlebars&quot; id=&quot;companies&quot;&gt;
  &lt;ul class=&quot;company-list&quot;&gt;
    {{#each}}
-     &lt;li&gt;{{name}}&lt;/li&gt;
+     &lt;li&gt;{{link-to name 'company' this}}&lt;/li&gt;
    {{/each}}
  &lt;/ul&gt;
&lt;/script&gt;
</code></pre>

<p>The first parameter is the text we want between our <code>a</code> tags; in this case, we'll use the company's name. The second paramter (<code>'company'</code>) is the name of the route we're linking to. The third is the model for that route; <code>this</code> refers to each company, the context of the <code>each</code> helper.</p>
<p>Now when we click our companies, we transition between routes, and the detail pane gets updated. Cool!</p>
<h3 id="a-basic-component">A basic component</h3>
<p>Components in Ember are similar to directives in Angular: they let you create resuable chunks of GUI that isolate templates and behavior. We'll use a component for our d3 chart, but first, let's see a quick example of how they work with just a simple template.</p>
<p>We'll turn our detail view into a template. The way our app is currently, wouldn't really warrant extracting out teh template into its own component. But again, it's just for illustrative purposes.</p>
<p>Creating a component is easy:</p>
<pre><code class="js">App.CompanyDetailComponent = Em.Component.extend({

});
</code></pre>

<p>Components must have two names, and end with <code>Component</code>. Now, we can specify the template in our HTML, alongside our other templates. We'll just extract the HTML we had in our <code>company</code> route, and move it to our component's template:</p>
<pre><code class="html">&lt;script type=&quot;text/x-handlebars&quot; id=&quot;components/company-detail&quot;&gt;
  &lt;h2&gt;{{name}}&lt;/h2&gt;

  &lt;p&gt;Last year we made {{revenue}}. Costs were {{cost}}.&lt;p&gt;
&lt;/script&gt;
</code></pre>

<p>We'll render our component in our <code>company</code> template (which, remember, corresponds to our company route). We render it like this: <code>{{company-detail}}</code>.</p>
<pre><code class="html">&lt;script type=&quot;text/x-handlebars&quot; id=&quot;company&quot;&gt;
  {{company-detail}}
&lt;/script&gt;
</code></pre>

<p>If you render this out, you'll notice just the static text is rendering. Why isn't it able to get the <code>name</code>, <code>revenue</code> and <code>cost</code> variables? We know the route has returned teh correct model.</p>
<p>The reason is that components have their own scope, apart from whatever template they're being rendered into. In this way they are similar to the isolate scope Angular directives we made earlier. So, we need to pass in the data our component needs to render.</p>
<p>One way is to pass each attribute in:</p>
<pre><code class="diff">&lt;script type=&quot;text/x-handlebars&quot; id=&quot;company&quot;&gt;
- {{company-detail}}
+ {{company-detail name=name revenue=revenue cost=cost}}
&lt;/script&gt;
</code></pre>

<p>but because this is a company detail component, it probably makes more sense to just pass the entire company model in. This creates a local <code>company</code> variable, so we need to update the template. We can either use <code>with</code>, or add <code>company.</code> in front of each variable:</p>
<pre><code class="diff">&lt;script type=&quot;text/x-handlebars&quot; id=&quot;company&quot;&gt;
- {{company-detail name=name revenue=revenue cost=cost}}
+ {{company-detail company=this}}
&lt;/script&gt;

&lt;script type=&quot;text/x-handlebars&quot; id=&quot;components/company-detail&quot;&gt;
+ {{#with company}}
    &lt;h2&gt;{{name}}&lt;/h2&gt;

    &lt;p&gt;Last year we made {{revenue}}. Costs were {{cost}}.&lt;p&gt;
+ {{/with}}
&lt;/script&gt;
</code></pre>

<p>Now we have a reusable <code>company-detail</code> component, and we can pass in any object to get the detail template rendered. We could also add additional behavior via our actual component object. Say, for example, we were using a jQuery plugin, and wanted to add some behavior to our component's element. We could do it like this:</p>
<pre><code class="js">App.CompanyDetailComponent = Em.Component.extend({

  didInsertElement: function() {
    this.get('element').tooltip(); // some fake jQuery plugin
  }

});
</code></pre>

<p>As you may have guessed, the actual JavaScript code behind the component - what we see here - is where we'll incorporate our D3 chart.</p>
<h3 id="d3-view_1">D3 view</h3>
<p>So why did I go over this? It's important to understand how routes work, because they are so central to Ember. Getting the routes set up correctly ensures that as your application grows in complexity, all the data will always be synced up and everythign will be in the right place. We'll now incorporate our bubble chart into our app in such a way that it honors this relationsihp with the router.</p>
<p>We'll essentially take the same approach as we did with Angular: wrap our bubble chart in a component. Our <code>CompanyDetail</code> component had a template and no code; our D3 component will be the opposite. We don't really need to specify a template, a single tag will do just fine. And we'll need to write some JavaScript code to actually instantiate our bubble chart, and set the options, just like we did in Angular.</p>
<p>First, we create the component, and assign our bubble chart to a property:</p>
<pre><code class="javascript">App.BubbleChartComponent = Em.Component.extend({
  chart: d3.charts.bubble()
    .emptyMessage('No companies.'),
});
</code></pre>

<p>Here we can set any static options on our chart. We could also bind properties (e.g. the empty message) to variables we pass in when we render our chart in the HTML.</p>
<p>If we want to customize our HTML element a little bit without writing a completely separate template, we have some options. For example, we can add a class name to the element, to let us style it:</p>
<pre><code class="diff">App.BubbleChartComponent = Em.Component.extend({
+ classNames: 'bubble-chart',

  chart: d3.charts.bubble()
    .emptyMessage('No companies.'),
});
</code></pre>

<p>Now let's write the D3 code. We'll add a <code>draw</code> method, and use our bubble chart's api:</p>
<pre><code class="diff">App.BubbleChartComponent = Em.Component.extend({
  classNames: 'bubble-chart',

  chart: d3.charts.bubble()
    .emptyMessage('No companies.'),

+ draw: function() {
+   d3.select(this.get('element'))
+     .data([ this.get('data') ])
+     .call(this.get('chart'));
+ }
});
</code></pre>

<p>After selecting the view's HTML element this with D3, we bind the data using <code>this.get('data')</code>. But you'll notice, we haven't defined the property <code>data</code>. Where does it come from?</p>
<p>Well, the idea here is similar to Angular. We're going to pass the data in when we render our component - so it will come from teh context of hte template. <code>data</code> is actually a property local tot he component's scope. This is again one of the benefits of components: their scope is isolated, and they require all their data to be explicitly passed in.</p>
<p>When we render it in our handlebars template, we'll do something like this:</p>
<pre><code class="html">{{bubble-chart data=chartData}}
</code></pre>

<p>and that's where the data will come from. But what is <code>chartData</code>?</p>
<p>In Ember, Controllers are used to decorate models. THey provide a place to do data manipulation and massaging to the raw data that's stored in our models, which comes from the server. Each route has its own controller - so when we're looking at the overall list of companies, we're actually alreayd using a CompaniesController. It's just that because we haven't had to overwrite the default functionality, Ember went ahead and created one for us.</p>
<p>In this case, the <code>CompaniesController</code> is the perfect place to add a function that manipulates our companies models into a format our bubble chart expects. Let's redefine the controller, and add the function.</p>
<p>We'll define the controller as an <code>ArrayController</code>, since it represents an array of models:</p>
<pre><code class="js">App.CompaniesController = Em.ArrayController.extend({

  chartData: function() {
    return {
      name: 'companies',
      children: this.map(function(c) {
        return {
          name: c.name,
          size: c.revenue
        };
      })
    };
  }.property('content')

});
</code></pre>

<p>Here we see the familiar data format our chart expects. We're returning an object with the children equal to plain objects. <code>this</code> refers to the array of companies, so we simply map it to an array containing only the data we need: name and size.</p>
<p>You'll notice the <code>property('content')</code> declaration at the end. This is a special type of function in Ember known as a computed property. Computed properties let you treat functions as if they were just properties storing data - so in the template we can put {{chartData}} - but whose data will be recalculated in the event one of their dependencies change. You specify dependencies as paramters to <code>.property()</code>. In essence, it's an easy way to set up your dependency graph. Also, CPs can depend on other CPs and they all lazily recalculate.</p>
<p>Here, we specify <code>content</code> as a dependency. <code>content</code> represents the actual array of models this controller is currently representing - so if the collection changes, this proeprty will be recalculated.</p>
<p>So, we now have the data we need in the format our chart expects. We render our bubble chart:</p>
<p>``html
{{bubble-chart data=chartData}}</p>
<pre><code>
and our bubble chart component now has a local `data` property that not only equals the initial value of our `chartData` computed property, but will update itself every time `chartData` changes.

Our chart renders! Now, let's add a dropdown to control whether revenue or cost is displayed. We can use Ember's select view to help us out:

```hbs
{{view Em.Select 
    content = 
    optionValuePath =
    optionLabelPath =
    value =
}}
</code></pre>

<p>When using this, we actually feed it data from a JavaScript array. We can just add the array to our controller:</p>
<pre><code class="diff">App.CompaniesController = Em.ArrayController.extend({

+ items: [
+   {item: 'revenue', label: 'Revenue'},
+   {item: 'cost', label: 'Cost'}
+ ],

  ...
</code></pre>

<p>and then link the select box to that data:</p>
<pre><code class="hbs">{{view Em.Select 
    content = items
    optionValuePath = 'content.item'
    optionLabelPath = 'content.label'
    value = selectedItem
}}
</code></pre>

<p>We've bound the selected dropdown item to a <code>selectedItem</code> property on our controller. Now let's alter our <code>chartData</code> function to use it:</p>
<pre><code class="diff">App.CompaniesController = Em.ArrayController.extend({
  chartData: function() {
+   var self = this;

    return {
      name: 'companies',
      children: this.map(function(c) {
        return {
          name: c.name,
-         size: c.revenue
+         size: c[self.get('selectedItem')]
        };
      })
    };
- }.property('content')
+ }.property('content', 'selectedItem')
});
</code></pre>

<p>That's it - our chart automatically responds, because we already told it to re-draw every time its <code>data</code> property changes, and now that changes every time <code>selectedItem</code> changes. Pretty cool!</p>
<h3 id="enhancing-our-chart">Enhancing our chart</h3>
<p>Now, wouldn't it be great if users could view the company details not only by selecting the links on the left, but also the bubbles in our chart? This is what we're going to add.</p>
<p>When we used the link helpers, they automatically took care of transitioning us to new routes when we clicked them. Behind the scenes, the link helper responds to the mouse click, and in the event handler calls <code>this.transitionTo('company', model)</code>. We want to do something similar when our user clicks on a bubble.</p>
<p>We can use <em>actions</em> to add custom event handlers to our components. Within our component code, we send an action in response to some event. Then, in our application code, we respond to the action, and do whatever we want. Let's see how it works.</p>
<p>We want to trigger an action when the user clicks a bubble. First, we add this trigger within our bubble chart.</p>
<p>We'll use <code>d3.dispatch</code> to dispatch an event. We'll call the event 'select', since the user is selecting a bubble:</p>
<pre><code class="js">// bubble-chart.js
var dispatch = d3.dispatch('select');

...

// Events
nodes.on('click', function(d, i) {
  dispatch.select(this, d, i);
});
</code></pre>

<p>We'll also add an accessor to our dispatcher, so code outside of the bubble chart - like our component - can subscribe to the event.</p>
<pre><code class="js">chart.dispatch = function(_) {
  if (!arguments.length) return dispatch;

  dispatch = _;

  return chart;
};
</code></pre>

<p>We've now augmented our bubble chart again with new functionality. Note that this has nothing to do with Ember yet - our stand-alone bubble chart now allows whoever's using it easily respond to click events on the bubbles, and do something with the data or DOM node.</p>
<p>Now in our component, we can respond to the chart's event and trigger an action within our Ember app. We'll do it in the <code>didInsertElement</code> hook:</p>
<pre><code class="diff">App.BubbleChartComponent = Em.Component.extend({
  classNames: 'bubble-chart',

  chart: d3.charts.bubble()
    .emptyMessage('No companies.'),

+ didInsertElement: function() {
+   this.get('chart').dispatch().on('select', function(el, d, i) {
+     self.sendAction('action', d, i);
+   });
+ },

  draw: function() {
    d3.select(this.get('element'))
      .data([ this.get('data') ])
      .call(this.get('chart'));
  }.observes('data').on('didInsertElement')

});
</code></pre>

<p>Now our component emits an action whenever a bubble is clicked, passing along the data and index of the clicked bubble. In our handlebars we can give the action a name:</p>
<pre><code class="diff">- {{bubble-chart data=chartData}}
+ {{bubble-chart data=chartData action='selectCompany'}}
</code></pre>

<p>and respond to it in our route:</p>
<pre><code class="js">App.CompaniesRoute = Em.Route.extend({

  model: function() {
    ...
  },

  actions: {
    selectCompany: function(d, i) {
      this.transitionTo('company', this.controller.objectAt(i));
    }
  }
</code></pre>

<p>Now, clicking the bubbles navigates our app - and the links stay in sync!</p>
<aside>We're using the index here to find which company to transition to, which is easy but only works in simple situations. In a more complex app, you'd want to use an id instead, which would involve you passing that data into your bubble chart, and having the chart emit it on the event.</aside>

<p>One final piece: it'd be nice if the bubbles showed us which company route we're on. Let's enhance the chart again, and give it some concept of its 'state': which data point has been selected. The strategy is to add an active class to the node that has been selected.</p>
<p>Now, we always have to think in terms of two-way binding. Think about the links for a second. When we click the link, the link helper gets the active class (that's how we could style it), and the app transitions. But if the app transitions some other way besides clicking the link - typing in the URL, using the back button, clicking on a bubble - the link still gets the active class. So when thinking about our bubbles, we don't want to just add an active class in the click event handler for the bubble, because someting else could make a company active.</p>
<p>Instead, let's abstract away from <em>what</em> may trigger a new selected company, and instead just add a generic method to our bubble chart:</p>
<pre><code class="js">// bubble-chart.js
chart.select = function(index) {
  nodes.classed('active', function(d, i) {
    return i === index;
  });
};
</code></pre>

<p>Now, whoever's using this chart can just invoke <code>chart.select(i)</code>, and the <em>ith</em> node will get an active class. We can then use CSS to style the node.</p>
<p>How do we hook this up to our Ember app? Well, we want the selected bubble to be bound to the currently active company. First, we can make a computed property on our <code>CompaniesController</code> that we'll be able to pass into our bubble chart. This CP should represent the currently selected company:</p>
<pre><code class="js">App.CompaniesController = Em.ArrayController.extend({
  ...
  needs: 'company',
  selectedCompany: Em.computed.alias('controllers.company.model')
});

// Need to redefine this for `needs` above
App.CompanyController = Em.ObjectController.extend();
</code></pre>

<p>There's a small trick we need to do to make this fully work. As it is currently written, <code>selectedCompany</code> will represent the company model as we navigate between models. But if we go back to the <code>CompaniesRoute</code>, <code>selectedCompany</code> will still be set to the last model that was chosen. This is becasue controllers are persistent in Ember, even when you leave route.</p>
<p>Since we want <code>selectedCompany</code> to be null when the user navigates back to the <code>CompaniesRoute</code>, we can force the <code>CompanyController</code>'s content to be null whenever the user leaves the route:</p>
<pre><code class="js">// App.CompanyRoute
deactivate: function() {
  this.controller.set('content', null);
}
</code></pre>

<p>Now, our CP faithfully represents the current model, including null if the user has not selected any model. We'll now pass this CP into our bubble chart component</p>
<pre><code class="html">{{bubble-chart data=chartData 
    action='selectCompany'
    selectedItem=selectedCompany }}
</code></pre>

<p>and update our component to invoke our bubble chart's "select" method whenever the <code>selectedCompany</code> property changes:</p>
<pre><code class="diff">App.BubbleChartComponent = Em.Component.extend({
  classNames: 'bubble-chart',

  chart: d3.charts.bubble()
    .emptyMessage('No companies.'),

  didInsertElement: function() {
    var self = this;

    this.get('chart').dispatch().on('select', function(el, d, i) {
      self.sendAction('action', d, i);
    });
  },

  draw: function() {
    d3.select(this.get('element'))
      .data([ this.get('data') ])
      .call(this.get('chart'));

    this.update();
  }.observes('data').on('didInsertElement'),

+ update: function() {
+   this.get('chart').selectItem(this.get('selectedItem'));
+ }.observes('selectedItem')

});
</code></pre>

<p>Our app now works as expected - you can navigate between routes using the list, the bubbles, the URL, and the back/forward buttons, and everything stays in sync!</p>
<h3 id="some-things-to-consider_2">Some things to consider</h3>
<ul>
<li>
<p>Notice, our bubble chart - and Ember component - don't know about "companies." So we've kept our code very decoupled - the "companies" part of it only comes in the template, from teh context of where we're rendering the actual chart. Pretty cool!</p>
</li>
<li>
<p>Ember data</p>
</li>
<li>
<p>Computed properties are awesome</p>
</li>
</ul>
<h2 id="wrapping-up">Wrapping up</h2>
<ul>
<li>
<p>All frameworks provide us with a place to do our data manipulation, so we can keep our D3 code agnostic about the particular format our data is in when in any framework. Alternatively, we could define a "transform" function on our chart, and in our framework objects, define that function to take the Backbone collection, angular model or ember array.</p>
</li>
<li>
<p>It's an iterative process. YOu build your d3 chart as OOP in isolation, and wrap it in a framework primitive. When you need new functionality, you go back to the chart and add it in a framework-agnostic way, exposing a hook for your framework objects to use. In this way you build a highly reusable chart, while still ending up with objects in your framework that are encpasulated and semantic, not just containers for 50 lines of D3. Also, you'll see patterns: you begin to expose core primitives of your charts, rather than options (i.e. expose the axis rather than axis.ticks, axis.tickSize, etc.). Makes them even more reusable.</p>
</li>
<li>
<p>There's definitely otehr approaches. http://alexandros.resin.io/angular-d3-svg/. Some people think using Ember or Angular makes D3's data binding redundant. But if you </p>
</li>
<li>
<p>Which framework is the best for D3? Answer, probably depends on scale. Though I'm most familiar with Ember, and use it even for "smaller" things now.</p>
</li>
<li>
<p>Framework binding vs. D3 binding</p>
</li>
<li>
<p>There's definitely a cost to keeping D3 code separate. Perhaps it sometimes makes sense to use the framework's primitives and write your D3 directly in them. Keeping it separate essentially makes you have to think about two apis: your chart's apis, and the apis of your components/directives/views. But you end up with charts that are reusable outside of the framework, which is a plus. Not to mention if you're using a library like d3.chart, which is specifically built for building reusable charts. However, inheritance and framework primitives like mixins may help you here as well.</p>
</li>
</ul>
<p>But the kind of work i've done, moving across many different projects and reusing a lot of code, it makes sense. Especially w/d3.chart.</p>
<p>https://www.youtube.com/watch?v=Hd2rye9a9kk&amp;feature=youtu.be
https://github.com/milroc/d3.MVC
http://bl.ocks.org/milroc/5519819
https://speakerdeck.com/sameersegal/combining-d3-dot-js-plus-backbone-dot-js-to-create-quick-realtime-graphs
http://shirley.quora.com/Marrying-Backbone-js-and-D3-js
http://mikemcdearmon.com/portfolio/techposts/charting-libraries-using-d3</p></body></html>